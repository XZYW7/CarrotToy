# 动态模块注册修复

## 日期: 2026-02-02

## 问题描述

运行应用程序（TestRHIApp、DefaultGame、CustomModule）时，只有静态链接的模块被注册到ModuleManager。控制台输出显示：

```
ModuleManager: Registering module TestRHIApp of type 3
ModuleManager: Registering module Launch of type 0
...
ModuleManager: Module CoreEngine not found in registry
ModuleManager: Module RHI not found in registry
ModuleManager: Module Renderer not found in registry
```

### 为什么会这样

模块系统使用 `IMPLEMENT_MODULE` 宏来注册模块：

```cpp
IMPLEMENT_MODULE(FMyModule, MyModuleName)
```

这个宏展开后会创建一个**全局静态对象**：

```cpp
static FStaticallyLinkedModuleRegistrant<FMyModule> ModuleRegistrantMyModuleName(TEXT("MyModuleName"), EModuleType::Engine);
```

这个全局对象的构造函数会将模块注册到 `FModuleManager`。

**对于静态库：**
- 链接器将对象文件包含到最终二进制文件中
- 全局构造函数在 `main()` 之前运行
- 模块被注册 ✅

**对于动态库（DLL/SO）：**
- 全局构造函数仅在DLL加载时运行
- 在Windows上，DLL只有在符号被显式引用时才会加载
- 没有引用，链接器不会加载DLL
- 全局构造函数永远不会运行
- 模块永远不会被注册 ❌

### 先有鸡还是先有蛋的问题

1. 要调用 `LoadModule("CoreEngine")`，模块必须先被注册
2. 要让Core DLL的注册代码运行，DLL必须先被加载
3. 要加载DLL，必须有符号被引用
4. 但在知道模块已加载之前，我们无法引用符号！

## 解决方案

### 添加强制加载函数

在每个模块中创建显式函数，应用程序可以引用这些函数来强制加载DLL：

**Core模块** (`EngineModules.h/cpp`):
```cpp
extern "C" void ForceCoreModuleLoad()
{
    // 这个函数的唯一目的是被应用程序引用
    // 以确保Core DLL被加载，触发全局构造函数
    // 从而将模块注册到FModuleManager
}
```

**RHI模块** (`RHIModule.cpp`):
```cpp
extern "C" void ForceRHIModuleLoad()
{
    // 强制加载RHI DLL
}
```

**Renderer模块** (`RendererModule.cpp`):
```cpp
extern "C" void ForceRendererModuleLoad()
{
    // 强制加载Renderer DLL
}
```

### 在加载模块前调用强制加载函数

在 `Launch.cpp` 中，在尝试加载模块之前添加调用：

```cpp
void FMainLoop::LoadPreInitModules()
{
    LOG("FMainLoop: Loading PreInit Modules");
    
    // 通过引用符号强制动态模块DLL加载
    // 这确保了它们的全局构造函数运行并注册模块
    ForceCoreModuleLoad();
    ForceRHIModuleLoad();
    ForceRendererModuleLoad();
    
    // 现在加载模块（它们已经注册了！）
    FModuleManager::Get().LoadModule("CoreEngine");
    FModuleManager::Get().LoadModule("RHI");
    FModuleManager::Get().LoadModule("Renderer");
    // ...
}
```

### 工作原理

1. **创建符号引用**: 应用程序调用 `ForceCoreModuleLoad()`
2. **链接器要求**: 链接器必须满足对这个函数的引用
3. **加载DLL**: 加载 Core.dll 以提供该函数
4. **运行构造函数**: Core.dll 中的所有全局构造函数执行
5. **注册模块**: `IMPLEMENT_MODULE(FCoreEngineModule, CoreEngine)` 运行，注册模块
6. **LoadModule成功**: `FModuleManager::Get().LoadModule("CoreEngine")` 在注册表中找到模块
7. **调用StartupModule**: 调用模块的 `StartupModule()`

## 为什么使用 `extern "C"`？

函数声明为 `extern "C"` 是为了：
- 防止C++名称修饰
- 使符号名称在不同编译器间可预测
- 确保链接器能找到符号

没有 `extern "C"`，函数名会被修饰（例如 `_Z19ForceCoreModuleLoadv`），使得引用变得不可靠。

## 替代方案（未使用）

### 1. 全部使用静态链接
**优点**: 简单，总是有效
**缺点**: 
- 可执行文件更大
- 无法热重载
- 用户希望使用动态链接

### 2. 对所有模块使用 `/WHOLEARCHIVE`
**优点**: 强制包含所有符号
**缺点**:
- 只对静态库有效
- 用户希望使用动态链接
- 违背了DLL的目的

### 3. 使用LoadLibrary显式加载DLL
**优点**: 直接控制DLL加载
**缺点**:
- 平台相关代码
- 需要在运行时查找DLL路径
- 更复杂

### 4. 模块初始化函数（选择的方案）
**优点**:
- 清晰简单的API
- 支持动态链接
- 跨平台
- 最小代码更改
**缺点**:
- 需要记住调用强制加载函数
- 稍微冗长

## 修复后的预期输出

```
ModuleManager: Registering module TestRHIApp of type 3
ModuleManager: Registering module CoreEngine of type 0    ← 新增！
ModuleManager: Registering module Launch of type 0
ModuleManager: Registering module RHI of type 0           ← 新增！
ModuleManager: Registering module Renderer of type 0       ← 新增！

FMainLoop: Loading PreInit Modules
FMainLoop: Loading Application Module: TestRHIApp
ModuleManager: Starting up module TestRHIApp
TestApplicationModule: Startup
...

ModuleManager: Starting up module CoreEngine               ← 新增！
CoreEngineModule: Startup                                  ← 新增！
CoreEngineModule: Initializing core engine systems         ← 新增！
ModuleManager: Module CoreEngine loaded successfully       ← 新增！

ModuleManager: Starting up module Launch
LaunchModule: Startup - Initializing launch subsystem
ModuleManager: Module Launch loaded successfully

ModuleManager: Starting up module RHI                      ← 新增！
RHIModule: Startup - Initializing RHI subsystem            ← 新增！
ModuleManager: Module RHI loaded successfully              ← 新增！

ModuleManager: Starting up module Renderer                 ← 新增！
RendererModule: Startup - Initializing renderer subsystem  ← 新增！
ModuleManager: Module Renderer loaded successfully         ← 新增！

FMainLoop: Loaded Engine Modules:
  - CoreEngine                                             ← 新增！
  - Launch
  - RHI                                                    ← 新增！
  - Renderer                                               ← 新增！
```

## 修改的文件

### 修改的文件：
1. `src/Runtime/Core/Public/Modules/EngineModules.h`
   - 添加了 `ForceCoreModuleLoad()` 声明

2. `src/Runtime/Core/Private/Modules/EngineModules.cpp`
   - 添加了 `ForceCoreModuleLoad()` 实现

3. `src/Runtime/RHI/Private/RHIModule.cpp`
   - 添加了 `ForceRHIModuleLoad()` 函数

4. `src/Runtime/Renderer/Public/RendererModule.h`
   - 添加了 `ForceRendererModuleLoad()` 声明

5. `src/Runtime/Renderer/Private/RendererModule.cpp`
   - 添加了 `ForceRendererModuleLoad()` 实现

6. `src/Runtime/Launch/Private/Launch.cpp`
   - 添加了模块头文件的包含
   - 在 `LoadPreInitModules()` 中调用强制加载函数

### 新增文件：
7. `src/Runtime/RHI/Public/RHI/RHIModule.h`
   - 创建并包含 `ForceRHIModuleLoad()` 声明

## 优点

✅ **保持动态链接**: 模块仍然是DLL/SO，符合用户要求  
✅ **跨平台**: 在Windows、Linux、macOS上都有效  
✅ **清晰的架构**: 对现有代码的最小更改  
✅ **面向未来**: 这个模式可以用于新模块  
✅ **支持热重载**: 动态模块仍然可以重载（未来功能）

## 新模块使用方法

创建新的动态链接模块时：

1. **在模块实现中添加强制加载函数**:
```cpp
extern "C" void ForceMyModuleLoad() {}
```

2. **在公共头文件中声明**:
```cpp
extern "C" void ForceMyModuleLoad();
```

3. **在Launch.cpp的LoadModule之前调用**:
```cpp
ForceMyModuleLoad();
FModuleManager::Get().LoadModule("MyModule");
```

## 参考文档

- [MODULE_LINKING_NOTES.md](./MODULE_LINKING_NOTES.md) - 技术链接细节
- [MODULE_SYSTEM_REFACTORING_2026_02_02.md](./MODULE_SYSTEM_REFACTORING_2026_02_02.md) - 模块系统概述
- `src/Runtime/Core/Public/Modules/Module.h` - IMPLEMENT_MODULE宏定义
